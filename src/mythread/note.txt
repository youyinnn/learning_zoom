程序(program)：
    是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。

进程(process)：
    是程序的一次执行过程，或是正在运行的一个程序。动态过程：有它自身的产生、存在和消亡的过程。
    程序是静态的，进程是动态的。

线程(thread)：
    进程可进一步细化为线程，是一个程序内部的一条执行路径。若一个程序可同一时间执行多个线程，就是支持多线程的。

Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来实现。

线程的实现方法：
    1、继承Thread类
    2、实现Runnable接口并实现run()方法

实现接口比继承Thread更好：
    1、避免了单继承
    2、适合多线程操作同一份资源的情况

Thread类的特性：
    每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体。
    通过该Thread对象的start()方法来调用这个线程。


Thread常用方法：
    start()：创建线程并执行对应的run()方法
    run()：子线程要执行的代码需要在这个方法里面实现或者调用
    currentThread()：静态 调取当前线程
    getName()：获取此线程的名字
    setName()：设置此线程的名字
----------------------------------------
    yield()：暂停当前正在执行的线程对象 并执行其他线程。
    join()：在线程a中调用b.join()方法时 表示 当执行到此方法时 a线程停止 执行b线程 直到b线程执行完毕 再接着执行a
    isAlive()：判断当前线程是否存活
    sleep(long a)：显示的让当前线程睡眠a毫秒
    线程通信：
        wait()  notify()  notifyAll()
    setPriority()：设置线程的优先级（1小10大） 优先级越大 抢占资源的成功率就越大
    getPriority()：获取当前线程的优先级



使用多线程的意义：
    1、提高应用的响应 对图形化界面更有意义
    2、提高CPU的利用率
    3、改善程序结构 将长而复杂的进程分为多个线程 独立运行 利于理解和修改

线程的分类：
    1、守护线程
    2、用户线程

    它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。
    守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。
    Java垃圾回收就是一个典型的守护线程。
    若JVM中都是守护线程，当前JVM将退出。


线程的生命周期：
    1、新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态
    2、就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件
    3、运行：当就绪的线程被调度并获得处理器资源时,便进入运行状态， run()方法定义了线程的操作和功能
    4、阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态
    5、死亡：线程完成了它的全部工作或线程被提前强制性地中止


线程的同步机制：
     方式一：同步代码块
         synchronized(对象（同步监视器）){
             //需要被同步的代码（需要操作共享数据的代码块）
         }
         同步监视器：可以由任何一个对象充当 哪个线程获取这个监视器 谁就执行大括号里面的代码 俗称：锁
                     要求所有的线程必须共用同一把锁！


     方式二：同步方法
        把操作共享数据的方法声明为synchronized 即将此方法声明为同步方法 能够保证当其中一个线程执行此方法时
        其他的线程在外等等直至此线程执行完此方法
        * 同步方法的锁：this（隐式） 所以要让锁有效的话 必须要保证this也就是上锁的方法的对象必须唯一

线程同步的弊端：
    同意时间多线程访问上锁的代码 效率会低 但这是有必要的

释放锁的操作：
    1、当前线程的同步方法、同步代码块执行结束
    2、当前线程在同步代码块、同步方法中遇到break、return等终止代码的执行
    3、当前线程在同步代码块、同步方法中出现了为处理的异常或者错误 导致线程结束
    4、当前线程在同步代码块、同步方法中执行了线程对象的wait()方法 当前线程暂停 并释放锁

死锁：
    不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁


线程通信：
    wait()：令当前线程挂起并放弃CPU、同步资源，使别的线程可访问并修改共享资源，
            而当前线程排队等候再次对资源的访问
    notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待
    notifyAll ()：唤醒正在排队等待资源的所有线程结束等待

    这三个方法是定义在Object类中的 三个方法只有在synchronized方法或synchronized代码块中才能使用
    否则会报java.lang.IllegalMonitorStateException异常


